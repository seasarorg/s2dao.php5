<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<!-- don't edit start -->
<head><title>Seasar - DI Container with AOP - </title><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<link href="seasar_b.css" type="text/css" rel="stylesheet"><script src="seasar_b.js" type="text/JavaScript" language="JavaScript"></script>
</head><body onload="preload('ja')"><table width="100%" border="0" cellspacing="0" cellpadding="0" align="left" height="100%"><tr>
<td align="left" valign="top" width="780"><table width="780" border="0" cellspacing="0" cellpadding="0" class="white">
<tr><td colspan="7"><img height="5" width="780" src="images/top01_b.gif" alt=""></td></tr>
<tr><td><img height="117" width="235" src="images/top02_b.gif" alt="Seasar"></td>
<td colspan="3"><img height="117" width="289" src="images/top03.gif" alt="DI Container with AOP"></td>
<td colspan="3"><img height="117" width="256" src="images/spacer.gif" alt=""></td>
</tr><tr><td rowspan="2"><img src="images/top04.gif" alt="" height="49" width="235"></td>
<td><a href="http://www.seasar.org/index.html"><img src="images/menu01_b_ja.gif" height="30" width="78" border="0" alt="" id="menu01" onmouseover="swap(1)" onmouseout="restore(1)"></a></td>
<td><a href="http://www.seasar.org/projects.html"><img src="images/menu02_b_ja.gif" height="30" width="101" border="0" alt="" id="menu02" onmouseover="swap(2)" onmouseout="restore(2)"></a></td>
<td><a href="http://www.seasar.org/products.html"><img src="images/menu03_b_ja.gif" height="30" width="110" border="0" alt="" id="menu03" onmouseover="swap(3)" onmouseout="restore(3)"></a></td>
<td><a href="http://www.seasar.org/resources.html"><img src="images/menu04_b_ja.gif" height="30" width="113" border="0" alt="" id="menu04" onmouseover="swap(4)" onmouseout="restore(4)"></a></td>
<td><img src="images/menu05_b_ja.gif" height="30" width="109" border="0" alt="" id="menu05" onmouseover="swap(5)" onmouseout="restore(5)"></td>
<td><img height="30" width="34" src="images/menu06.gif" alt=""></td></tr><tr>
<td colspan="6"><img height="19" width="545" src="images/spacer.gif" alt=""></td></tr></table>
<table  width="780" border="0" cellspacing="0" cellpadding="0" height="100%" class="white">
<tr align="left" valign="top"><td width="14"><img height="14" width="14" src="images/spacer.gif" alt=""></td><td width="752" class="main">
<!-- don't edit end -->
<!-- document start -->

    <ul>
        <li><a href="#reference">S2Dao.PHP5リファレンス</a>
            <ul>
                <li><a href="#DaoMakeFile">作成すべきファイル</a></li>
                    <ul>
                        <li type="circle"><a href="#Entity">Entity</a></li>
                            <ul>
                                <li><a href="#TableAnnotation">TABLEアノテーション</a></li>
                                <li><a href="#ColumnAnnotation">COLUMNアノテーション</a></li>
                                <li><a href="#N1Mapping">N:1マッピング</a></li>
                                <li><a href="#IDAutoGenerate">IDの自動生成</a></li>
                                <li><a href="#NoPersistentColumns">永続化されないカラム</a></li>
                                <li><a href="#VersionNoPropertyAnnotation">VERSION_NO_PROPERTYアノテーション</a></li>
                                <li><a href="#TimestampPropertyAnnotation">TIMESTAMP_PROPERTYアノテーション</a></li>
                                <li><a href="#property">カラムに対応するプロパティの宣言</a></li>
                                <li><a href="#GetterSetterMethod">getter/setterメソッドの実装</a></li>
                            </ul>
                        <li type="circle"><a href="#Dao">Dao(Data Access Object)</a></li>
                            <ul>
                                <li><a href="#BeanAnnotation">BEANアノテーション</a></li>
                                <li><a href="#ArgsAnnotation">ARGSアノテーション</a></li>
                                <li><a href="#QueryAnnotation">QUERYアノテーション</a></li>
                                <li><a href="#DefMethod">メソッドの定義</a></li>
                                <li><a href="#NoPersistentPropsAnnotation">NO_PERSISTENT_PROPSアノテーション</a></li>
                                <li><a href="#PersistentPropsAnnotation">PERSISTENT_PROPSアノテーション</a></li>
                                <li><a href="#SqlAnnotation">SQLアノテーション</a></li>
                                <li><a href="#ProcedureAnnotation">PROCEDUREアノテーション</a></li>
                            </ul>
                        <li type="circle"><a href="#diconfile">diconファイル</a></li>
                        <li type="circle"><a href="#SQLfile">SQLファイル</a></li>
                    </ul>
                <li><a href="#SQLBind">SQLコメント</a></li>
                <li><a href="#EntityManager">EntityManagerを使用したQueryの実行</a>
                <li><a href="#AutoUpdate">更新SQLの自動生成</a></li>
                <li><a href="#AutoSelect">検索SQLの自動生成 </a></li>
                <li><a href="#IDAutoGenerate">IDの自動生成 </a></li>
                <li><a href="#VersionNo">VersionNoによる排他制御 </a></li>
                <li><a href="#Timestamp">Timestampによる排他制御 </a></li>
                <li><a href="#Annotation">定数アノテーションとコメントアノテーション</a></li>
                <li><a href="#HowToRun">S2Daoの実行</a></li>
            </ul>
        </li>
    </ul>

    <h2><a name="reference">S2Dao.PHP5リファレンス</a></h2>

    <h3><a name="DaoMakeFile">作成すべきファイル</a></h3>
        <p>S2Dao機能を使用するにあたり、Entity、Dao、diconファイル、SQLファイル(.sql)の作成が必要となります。</p>
        <p>詳細なドキュメントは<a href="http://s2dao.seasar.org/">Java版S2Dao</a>をご覧になってください。</p>

        <p>Entityはテーブル、DaoはEntity、diconファイルはDao、SQLファイルはDaoとそれぞれ関連しています。<br />
        各ファイルの実装・設定方法の詳細は次のようになります。</p>

    <h4><a name="Entity">Entity(Bean)</a></h4>
        <p>Entityはテーブルとの関連付けに使用します。
        Entityにテーブルの関連付けを行うには、以下の定数宣言とメソッドの実装が必要になります。</p>

        <ul>
            <li>テーブルとの関連付けの定数宣言 (<a href="#TableAnnotation">TABLEアノテーション</a>)</li>
            <li>カラムとの関連付けの定数宣言 (<a href="#ColumnAnnotation">COLUMNアノテーション</a>)</li>
            <li>別テーブルと結合する場合はキーとなる定数宣言(<a href="#N1Mapping">N:1マッピング</a>)</li>
            <li><a href="#IDAutoGenerate">IDの自動生成</a></li>
            <li><a href="#NoPersistentColumns">永続化されないカラム</a></li>
            <li><a href="#property">カラムに対応するプロパティの宣言</a><il>
            <li><a href="#GetterSetterMethod">getter/setterメソッドの実装</a></li>
        </ul>

        <p>Entityの構成と説明内で使用するテーブルは以下の通りです。</p>

        <p>テーブル：EMP</p>
        <table border="1" class="main">
            <tr bgcolor="#d1f3f4" align="center">
                <th>カラム名</th>
                <th>型</th>
                <th>NotNull</th>
                <th>主キー</th>
            </tr>
            <tr>
                <td>EMPNO</td>
                <td>NUMBER</td>
                <td align="center">〇</td>
                <td align="center">〇</td>
            </tr>
            <tr>
                <td>ENAME</td>
                <td>VARCHAR</td>
                <td>&nbsp;</td>
                <td>&nbsp;</td>
            </tr>
            <tr>
                <td>DEPTNUM</td>
                <td>NUMBER</td>
                <td>&nbsp;</td>
                <td>&nbsp;</td>
            </tr>
        </table>

        <p>テーブル：DEPT</p>
        <table border="1" class="main">
            <tr bgcolor="#d1f3f4" align="center">
                <th>カラム名</th>
                <th>型</th>
                <th>NotNull</th>
                <th>主キー</th>
            </tr>
            <tr>
                <td>DEPTNO</td>
                <td>NUMBER</td>
                <td align="center">〇</td>
                <td align="center">〇</td>
            </tr>
            <tr>
                <td>DNAME</td>
                <td>VARCHAR</td>
                <td>&nbsp;</td>
                <td>&nbsp;</td>
            </tr>
        </table>

    <h5><a name="TableAnnotation">TABLEアノテーション</a></h5>

        <p>テーブルとの関連付けはTABLEアノテーションを使用します。
        TABLEアノテーションは以下の形式で定数を宣言します。</p>

        <p> -  const TABLE = “<span class="italic">テーブル名</span>”;</p>
        <p>EMPテーブルの場合以下のようになります。</p>
        <pre>const TABLE = "EMP";</pre>

        <p>コメントアノテーションを行う場合は以下のように記述します。</p>
        <p> - @Bean(table = <span class="italic">テーブル名</span>)</p>
        <p>EMPテーブルの場合以下のようになります。</p>
<pre>
/**
 * @Bean(table = EMP)
 */
class Employee {
    :
    :
}</pre>

        <p>※クラス名からパッケージ名を除いた名前がテーブル名と一致する場合は、TABLEアノテーションを定義する必要はありません。</p>

    <h5><a name="ColumnAnnotation">COLUMNアノテーション</a></h5>

        <p>テーブルのカラムとの関連付けはCOLUMNアノテーションを使用します。<br />
        COLUMNアノテーションは以下の形式で定数を宣言します。</p>

        <p> -  const <span class="italic">プロパティ名</span>_COLUMN = "<span class="italic">カラム名</span>";</p>
        <p>employeeNoというプロパティにEMPNOカラムを関連付けする場合以下のようになります。</p>
        <pre>const employeeNo_COLUMN = "EMPNO";</pre>

        <p>コメントアノテーションを行う場合は以下のように記述します。</p>
        <p> - @Column("<span class="italic">カラム名</span>")
        <p>employeeNoというプロパティにEMPNOカラムを関連付けする場合以下のようになります。</p>
<pre>
/**
 * @Column("EMPNO")
 */
private $employeeNo;
</pre>

        <p>※プロパティ名とカラム名が一致する場合は、COLUMNアノテーションを定義する必要はありません。<br />
        テーブルに存在しないプロパティは、自動的に無視されるので、特に何か定義する必要はありません。</p>

     <h5><a name="N1Mapping">N:1マッピング</a></h5>

         <p>N:1マッピングとは、複数の従業員の行に1つの部署の行が関連付けられるような場合のマッピングです。<br />
         N:1マッピングを使用するには、RELNO定数とRELKEYS定数をそれぞれ宣言する必要があります。<br />
         RELNO定数は以下の形式になります。</p>

        <p>-  const <span class="italic">プロパティ名</span>_RELNO = <span class="italic">数値</span>;</p>
        <p>RELNO定数は、N:1マッピングの連番です。<br />
        例えば、AAAのテーブルにBBB,CCCのテーブルがN:1マッピングされるとするとBBBのRELNOは0、CCCのRELNOは1になります。 <br />
        RELNOは結果セットに含まれているカラムが、どのテーブルに所属しているのかを判定することに使われます。<br />
        例えば、SELECT ..., BBB.HOGE AS HOGE_0, ... FROM AAA, BBB ...のようなSELECT文があった場合、 HOGE_0はBBBテーブルに含まれているHOGEカラムであると認識されます。<br />
        RELKEYS定数は以下の形式になります。</p>

        <p>-  const <span class="italic">プロパティ名</span>_RELKEYS = "<span class="italic">N側のテーブルのカラム名: 1側のテーブルのカラム名</span>";</p>
        <p>N:1マッピングのキーはRELKEYS定数で指定します。<br />
        キーが複数ある場合には、カンマ( , )で区切ります。例えば、mykey1:yourkey1, mykey2:yourkey2のようにします。<br />
        EMPテーブルのDEPTNUMカラムとDEPTテーブルのDEPTNOを関連付ける場合は以下のようになります。</p>
<pre>
const department_RELNO = 0;
const department_RELKEYS = "DEPTNUM:DEPTNO";
</pre>

        <p>上記の場合のコメントアノテーションを行う場合は以下のように記述します。</p>
<pre>
/**
 * @Relation(relationNo = 0, relationKey = "DEPTNUM:DEPTNO")
 */
private $department;
</pre>

        <p>1側のテーブルのカラム名がN側のテーブルのカラム名に等しい場合は、1側のテーブルのカラム名を省略することができます。<br />
        その場合以下のように定義することが出来ます。</p>
        <pre>const department_RELKEYS = "DEPTNO";</pre>
        <p>また1側のテーブルのカラム名とN側のテーブルのカラム名に等しく、1側のテーブルのカラム名がプライマリーキーの場合、RELKEYS定数を省略することができます。</p>

    <h5><a name="IDAutoGenerate">IDの自動生成</a></h5>

        <p>ID(プライマリーキー)をRDBMSに自動生成させて、自動生成された値をBeanに自動的に設定することが出来ます。<br />
        そのために使うのが、IDアノテーションです。<br />
        IDアノテーションは、プロパティ名_ID = &quot;identity&quot;のように指定します。 </p>
        <pre>const id_ID = "identity";</pre>

        <p>SEQUENCEを使うことも出来ます。myseqの部分は、実際のSEQUENCEに置き換えてください。</p>
        <pre>const id_ID = "sequence, sequenceName=myseq";</pre>

        <p>手動でIDを設定する場合は、何も指定する必要がありません。<br />
        テーブルのプライマリーキーだという情報は、テーブルの定義(PDOのメタデータ)より自動的に取得されます。
        また、明示的にassignedを指定することもできます。</p>
        <pre>const id_ID = "assigned";</pre>

       <p>コメントアノテーションを行う場合は以下のように記述します。</p>
<pre>
/**
 * @Id(identity)
 */
private $id;
</pre>

    <h5><a name="NoPersistentColumns">永続化されないカラム</a></h5>

        <p>カラムが永続化の対象かどうかという情報は、テーブルの定義(PDOのメタデータ)より自動的に取得されます。
        また、明示的にNO_PERSISTENT_PROPSを使って永続化したくないカラムを指定することもできます。
        NO_PERSISTENT_PROPSに空文字を指定するとPDOのメタデータのメタデータを使わずにすべてのプロパティを永続化の対象とみなします。</p>
        <pre>const NO_PERSISTENT_PROPS = "dummy1, dummy2";</pre>
        <p>またコメントアノテーションで指定する場合は以下の書式で記述します</p>
<pre>
/**
 * @Bean(table = EMP)
 * @NoPersistentProperty(dummy1, dummy2)
 */
class Employee {
    private $dummy1;
    private $dummy2;
      :
      :
}
</pre>

    <h5><a name="VersionNoPropertyAnnotation">VERSION_NO_PROPERTYアノテーション</a></h5>

        <p><a href="#VersionNo">versionNo</a>による排他制御用のプロパティ名をデフォルトのversionNoから変えるときに使うのがVERSION_NO_PROPERTYアノテーションです。
        次のように使います。</p>
        <pre>const VERSION_NO_PROPERTY = "myVersionNo";</pre>
        <p>またコメントアノテーションで指定する場合は以下の書式で記述します</p>
<pre>
/**
 * @Bean(table = EMP)
 * @VersionNoProperty(myVersionNo)
 */
class Employee {
    private $myVersionNo;
      :
      :
}
</pre>

    <h5><a name="TimestampPropertyAnnotation">TIMESTAMP_PROPERTYアノテーション</a></h5>

        <p><a href="#Timestamp">timestamp</a>による排他制御用のプロパティ名をデフォルトのtimestampから変えるときに使うのがTIMESTAMP_PROPERTYアノテーションです。次のように使います。</p>
        <pre>const TIMESTAMP_PROPERTY = "myTimestamp";</pre>
        <p>またコメントアノテーションで指定する場合は以下の書式で記述します</p>
<pre>
/**
 * @Bean(table = EMP)
 * @TimestampProperty(myTimestamp)
 */
class Employee {
    private $myTimestamp;
      :
      :
}
</pre>

    <h5><a name="property">カラムに対応するプロパティの宣言</a></h5>

        <p>テーブルのカラムに対応した変数を宣言します。</p>
        <p>EMPNOというカラムの場合、以下のように宣言することができます。<p>
        <pre>private $empno;</pre>

     <h5><a name="GetterSetterMethod">getter/setterメソッド</a></h5>

        <p>テーブルのカラムに対応した各プロパティのgetter/setterメソッドを実装します。メソッドの命名規則は以下の形式になります。</p>
        <p>getterメソッド</p>
        <p> - public <span class="italic">function</span> get<span class="italic">プロパティ名</span>()</p>

        <p>setterメソッド</p>
        <p> - public function set<span class="italic">プロパティ名(引数)</span></p>

        <p>private $empno;というプロパティの場合は以下のようになります。</p>

<pre>private $empno;

public function getEmpno() {
    return $this-&gt;empno;
}

public function setEmpno($empno) {
    $this-&gt;empno = $empno;
}
</pre>

        <p>以上の設定を行ったEMPテーブルに関連付くEntityは次のようになります。</p>

<pre>&lt;?php
class Employee {

    const TABLE = "EMP";

    private $empno;

    private $ename;

    private $deptnum;

    private $department;

    public function Employee() {
    }

    public function getDepartment() {
        return $this-&gt;department;
    }

    public function setDepartment(Department $department) {
        $this-&gt;department = $department;
    }

    public function getDeptnum() {
        return $this-&gt;deptnum;
    }

    public function setDeptnum($deptnum) {
        $this-&gt;deptnum = $deptnum;
    }

    public function getEmpno() {
        return $this-&gt;empno;
    }

    public function setEmpno($empno) {
        $this-&gt;empno = $empno;
    }

    public function getEname() {
        return $this-&gt;ename;
    }

    public function setEname($ename) {
        $this-&gt;ename = $ename;
    }
}
?&gt;</pre>

    <h4><a name="Dao">Dao(Data Access Object)</a></h4>

        <p>Daoはインターフェースとして作成します。永続化されるデータとロジックを分離して、Dao本来の目的であるBeanの永続化を行います。
        Entityとは1：1の関係にあるので、一つのEntityに対して一つのDaoを作成することになります。
        Daoのメソッドを呼ぶことにより、メソッドに対応したSQLファイルに記述されているSQLが実行されます。
        Daoを作成するには、以下の点が必要になります。</p>

        <ul>
            <li>Entityとの関連付けの定数宣言(<a href="#BeanAnnotation">BEANアノテーション</a>)</li>
            <li><a href="#DefMethod">メソッドの定義</a></li>
        </ul>

        <p>またメソッドの引数をSQL文で参照したり、WHERE句、ORDER句を追加、更新のSQLに含めない、あるいは含めるプロパティを指定する場合には、以下のアノテーションを使います。</p>

        <ul>
            <li><a href="#ArgsAnnotation">ARGSアノテーション</a></li>
            <li><a href="#QueryAnnotation">QUERYアノテーション</a></li>
            <li><a href="#NoPersistentPropsAnnotation">NO_PERSISTENT_PROPSアノテーション</a></li>
            <li><a href="#PersistentPropsAnnotation">PERSISTENT_PROPSアノテーション</a></li>
            <li><a href="#SqlAnnotation">SQLアノテーション</a></li>
        </ul>

    <h5><a name="BeanAnnotation">BEANアノテーション</a></h5>

        <p>DaoがどのEntity(エンティティ)に関連付けられているのかはBEANアノテーションで指定します。<br />
        BEANアノテーションは以下の形式で定数を宣言します。</p>
        <p> - const BEAN = "<span class="italic">Bean(Entity)名</span>";</p>
        <p>EmployeeDaoクラスがEmployeeエンティティに関連付けられる場合は次のように定義します。</p>
        <pre>const BEAN = "Employee";</pre>

        <p>コメントアノテーションを行う場合は以下のように記述します。</p>
        <p> - @Dao(bean = <span class="italic">Bean(Entity)名</span>)</p>
        <p>EmployeeDaoクラスがEmployeeエンティティに関連付けられる場合は次のように定義します。</p>
<pre>
/**
 * @Dao(bean = Employee)
 */
interface EmployeeDao {
    :
    :
}</pre>

    <h5><a name="ArgsAnnotation">ARGSアノテーション</a></h5>

        <p>メソッドの引数をSQL文で参照できるように、ARGSアノテーションを使用し、メソッドの引数名を指定することもできます。<br />
        ARGSアノテーションは以下の形式で定数を宣言します。</p>
        <p> - const <span class="italic">メソッド名</span>_ARGS = "<span class="italic">引数名</span>";</p>

         <p>public function getEmployeeList($empno)というメソッドがDaoに定義されていた場合の引数名は次のように定義します。</p>
         <pre>const getEmployeeList_ARGS = "empno";</pre>

         <p>コメントアノテーションを行うには以下のように記述します。</p>
<pre>
/**
 * @Arguments(empno)
 */
public function getEmployee($empno);
</pre>

        <p>また、ARGSアノテーションは省略することができます。<br />
        省略した場合は、メソッドの引数名がそのまま使われます。</p>
        <p>例えば以下のようなメソッドの場合</p>
        <pre>public function methodA($id, $name, $age);</pre>

        <p>もし、ARGSアノテーションを省略した場合、 id, name, age が利用されます。<br />
        よって上のメソッドの場合以下のARGSアノテーションが省略可能です。</p>
        <pre>//const methodA_ARGS = "id, name, age";</pre>

    <h5><a name="QueryAnnotation">QUERYアノテーション</a></h5>

        <p>自動的に生成されるSELECT文にWHERE句やORDER BY句を追加するには、QUERYアノテーションを使用します。<br />
        QUERYアノテーションは以下の形式で定数を宣言します。</p>

        <p> - const <span class="italic">メソッド名</span>_QUERY = "<span class="italic">WHERE句ORDER BY句</span>";</p>
        <p>引数で給与の上限と下限を指定し、その間に含まれる従業員を抽出する場合、次のようにします。</p>

<pre>
const getEmployeesBySalList_QUERY = "sal BETWEEN ? AND ? ORDER BY empno";
public function getEmployeesBySalList($minSal, $maxSal);
</pre>

        <p>コメントアノテーションを行う場合には以下のように記述します。</p>
<pre>
/**
 * @Query("sal BETWEEN ? AND ? ORDER BY empno")
 */
public function getEmployeesBySal($minSal, $maxSal);
</pre>

        <p>上記例の“?”をバインド変数と言います。
        バインド変数をQUERYアノテーションに記述することにより、メソッドの引数の値が順に”?”の部分に代入されます。
        ARGSアノテーションは、必要ありません。ORDER BY句だけを記述するときは、ORDER BYで始めてください。<a href="#SQLbind">SQLコメント</a>も記述することが出来ます。
        SQLコメントを使用したサンプルは以下のとおりです。</p>

<pre>const getEmployeesList_QUERY =
            "job = /*job*/'CLERK'/*IF deptno != null*/ AND deptno = /*deptno*/20/*END*/";
</pre>

        <p>上記サンプルは、引数deptnoがnullでない場合、deptnoが引数の値と一致するという条件を追加します。SQLコメントについての詳しい説明は、<a href="#SQLbind">SQLコメント</a>の項目を参照して下さい。</p>

    <h5><a name="DefMethod">メソッドの定義</a></h5>

        <p>Daoに定義したメソッドを呼ぶことにより、対応するSQLファイルに記述されているSQLが実行されますが、
        更新(INSERT, UPDATE, DELETE)、検索処理ごとにメソッドの命名規則があります。S2Daoではメソッドの命名規則よりSQL文の中身を自動的に決定しています。
        また、定義するメソッドのオーバーロードはサポートしていません。</p>

        <ul>
            <li>INSERT処理</li>
                <p>INSERT処理を行なうメソッドの名前が、insert, add, createではじまる必要があります。<br />
                更新した行数が戻り値となります。引数の型はエンティティの型と一致させます。<br />
                メソッドの定義例は以下のようになります。</p>

<pre>
public function insert(Department $department);
public function addDept(Department $department);
public function createDept(Department $department);
</pre>

        <li>UPDATE処理</li>
            <p>UPDATE処理を行うメソッドの名前が、update,modify,storeではじまる必要があります。<br />
            更新した行数が戻り値となります。引数の型はエンティティの型と一致させます。<br />
            メソッドの定義例は以下のようになります。</p>

<pre>
public function update(Department $department);
public function modifyDept(Department $department);
public function storeDept(Department $department);
</pre>

        <li>DELETE処理</li>
            <p>DELETE処理を行うメソッドの名前が、delete,removeではじまる必要があります。<br />
            更新した行数が戻り値となります。引数の型はエンティティの型と一致させます。<br />
            メソッドの定義例は以下のようになります。</p>

<pre>
public function delete(Department $department);
public function removeDept(Department $department);
</pre>

        <li>検索(SELECT)処理
            <p>検索処理を行ないたい場合は、メソッド名の最後が<span class="italic">List</span>または、<span class="italic">Array</span>で終わっている必要があります。<br />
            もし<span class="italic">List</span>または、<span class="italic">Array</span>で終わっていない場合は単一のEntity(Bean)を返します。<br />
            また、List、Arrayなどは大文字小文字を判別しません。</p>

            <ul>
                <li>List形式の戻り値
                    <p>Listで終わるメソッド名の場合は、SELECT文でエンティティのリスト(S2Dao_ArrayList形式)を返します。<br />
                    (S2Dao_ArrayListはS2Dao.PHP5の組み込みクラスです。JavaのArrayListと同じような機能を提供します。)<br />
                    以下のように記述することができます。</p>
<pre>
public function getEmpList();
</pre>
                    <p>コメントアノテーションを行う場合は以下のように記述します。</p>
<pre>
/**
 * @return list
 */
public function getEmp();
</pre>
</li>
                <li>Array形式の戻り値
                    <p>Arrayで終わるメソッド名の場合は、エンティティの連想配列(<span class="italic">array()</span>)を返します。<br />
                        以下のように記述することができます。</p>
<pre>
public function getEmpArray();
</pre>

            <p>コメントアノテーションを行う場合は以下のように記述します。</p>
<pre>
/**
 * @return array
 */
public function getEmp();
</pre>
</li>
                <li>YAML形式の戻り値
                    <p>Yamlで終わるメソッド名の場合は、YAML形式の戻り値を返します。<br />
                    以下のように記述することができます。</p>
<pre>
public function getEmpYaml();
</pre>
                    <p>コメントアノテーションを行う場合は以下のように記述します。</p>
<pre>
/**
 * @return yaml
 */
public function getEmp();
</pre>
                    <p>※YAML形式の戻り値を取得するためにはSpyc(<a href="http://spyc.sourceforge.net/" title="spyc: a simple php yaml class">http://spyc.sourceforge.net/</a>)を読み込んでおく必要があります。</p>
<pre>
require_once "spyc.php";
:
:
</pre>
</li>

                <li>JSON形式の戻り値
                    <p>Jsonで終わるメソッド名の場合は、JSON形式の戻り値を返します。<br />
                    以下のように記述することができます。</p>
<pre>
public function getEmpJson();
</pre>
                    <p>コメントアノテーションを行う場合は以下のように記述します。</p>
<pre>
/**
 * @return json
 */
public function getEmp();
</pre>
                    <p>※JSON形式の戻り値を取得するためにはphp-jsonのPHP拡張(<a href="http://www.aurore.net/projects/php-json/" title="omar kilani - projects - php-json">http://www.aurore.net/projects/php-json/</a>)を使用します。<br />
                        使用するにはphp.iniなどにjson.so(php_json.dll)を読み込んでおいてください。</p>
<pre>
extension=json.so(extension=php_json.dll)
</pre>
</li>
                </ul>
            </li>
        </ul>

    <h5><a name="NoPersistentPropsAnnotation">NO_PERSISTENT_PROPSアノテーション</a></h5>

        <p>更新するときに、このプロパティは、SQLに含めて欲しくないという場合もあります。
        そのような場合は、NO_PERSISTENT_PROPSアノテーションを使います。</p>
        <pre>const insert_NO_PERSISTENT_PROPS = "sal, comm";</pre>
        <p>上記のように指定すると、insertメソッドで、salとcommプロパティは永続化の対象になりません。</p>

        <p>コメントアノテーションを行う場合は以下のように記述します。</p>
<pre>
/**
 * @NoPersistentProperty(sal, comm)
 */
public function insert(Department $department);
</pre>

    <h5><a name="PersistentPropsAnnotation">PERSISTENT_PROPSアノテーション</a></h5>

        <p>更新するときに、このプロパティだけをSQLに含めたいという場合もあります。
        そのような場合は、PERSISTENT_PROPSアノテーションを使います。</p>
        <pre>const update_PERSISTENT_PROPS = "deptno";</pre>
        <p>上記のように指定すると、updateメソッドで、プライマリーキー、versionNo、timestampのプロパティに加えて、
        PERSISTENT_PROPSアノテーションで指定したプロパティが永続化の対象になります。</p>

        <p>コメントアノテーションを行う場合は以下のように記述します。</p>
<pre>
/**
 * @PersistentProperty("deptno")
 */
public function update(Department $department);
</pre>

    <h5><a name="SqlAnnotation">SQLアノテーション</a></h5>

        <p>SQLアノテーションを使用することが可能です。<br />
        機能はSQLファイルと同様で、アノテーションにてSQL及びSQLコメントを使用することが可能です。</p>
        <p>SQLアノテーションに命名規則があります。</p>

        <ul>
            <li>SQLファイルとDaoに定義したメソッドの関連付け</li>
                <p>SQLアノテーションとDaoに定義したメソッドの関連付けをするには、SQLアノテーションを以下の形式にする必要があります。</p>
                <p> - const <span class="italic">メソッド名</span>_SQL</p>
                <p>EmployeeDao::getAllEmployeesList()に対応するSQLアノテーションは以下のようになります。</p>

<pre>const getAllEmployeesList_SQL = "SELECT
emp.*, dept.dname dname_0, dept.loc loc_0 FROM emp, dept
 WHERE emp.deptno = dept.deptno ORDER BY emp.empno;";
</pre>

                <p>コメントアノテーションを行う場合は以下のように記述します。</p>
<pre>
/**
 * @Sql("SELECT * FROM EMP WHERE EMPNO > 1")
 */
public function getAllEmployees();
</pre>

            <li>複数DBMS対応</li>
                <p>DBMSごとに使用するSQLアノテーションを指定することができます。<br />
                どのDBMSを使っているのかは PDO::ATTR_DRIVER_NAME の値に応じて、S2Dao が自動的に判断しています。<br />
                S2Dao.PHP5でDBMSごとにサフィックスを決めているので、SQLアノテーションにサフィックスを追加します。<br />
                例えばMySQLの場合、サフィックスはmysqlなので、「getAllEmployeesList_mysql_SQL」というSQLアノテーションになります。</p>

            <p>DBMSとサフィックスの関係は以下の通りです。</p>
            <table class="main" border="1">
                <tr align="center" bgcolor="#d1f3f4">
                    <th scope="col">DBMS</th>
                    <th scope="col">サフィックス</th>
                </tr>
                <tr>
                    <td>Oracle</td>
                    <td>oracle</td>
                </tr>
                <tr>
                    <td>Firebird</td>
                    <td>firebird</td>
                </tr>
                <tr>
                    <td>MySQL</td>
                    <td>mysql</td>
                </tr>
                <tr>
                    <td>PostgreSQL</td>
                    <td>pgsql</td>
                </tr>
                <tr>
                    <td>SQLite</td>
                    <td>sqlite</td>
                </tr>
                <tr>
                    <td>Sybase</td>
                    <td>sybase</td>
                </tr>
            </table>
        </ul>

    <h5><a name="ProcedureAnnotation">PROCEDUREアノテーション</a></h5>

    <p>バージョンRC3より、PROCEDUREアノテーションを使用することによりStoredProcedureやStoredFunctionを実行することができます。
    PROCEDUREアノテーションは以下の形式のうちいずれかを指定します。</p>
    <p>-  const <span class="italic">メソッド名</span>_PROCEDURE = "<span class="italic">カタログ名.スキーマ名.プロシジャ名</span>";</p>
    <p>-  const <span class="italic">メソッド名</span>_PROCEDURE = "<span class="italic">スキーマ名.プロシジャ名</span>";</p>
    <p>-  const <span class="italic">メソッド名</span>_PROCEDURE = "<span class="italic">プロシジャ名</span>";</p>

    <ul>
        <li>サポートされるStoredProcedureの範囲について</li>
        <p>PROCEDUREアノテーションでは、戻り値のあるStoredProcedureおよびINパラメータを複数持つプロシジャーをサポートしています。
        ただし、OUTやINOUTパラメータは現在のところ対応していません。</p>
        <p>また、DBMSやPDOのバージョンによっては、利用できない場合があります。</p>

        <table class="main" border="1">
            <tr align="center" bgcolor="#d1f3f4">
                <th scope="col">DBMS</th>
                <th scope="col">制限事項</th>
            </tr>
            <tr>
                <td>Oracle</td>
                <td>現在利用不可です。</td>
            </tr>
            <tr>
                <td>MySQL</td>
                <td>INパラメータをもつStoredFunctionおよびStoredProcedureをサポートしています。</td>
            </tr>
            <tr>
                <td>PostgreSQL</td>
                <td>INパラメータをもつStoredFunctionおよびStoredProcedureをサポートしています。</td>
            </tr>
            <tr>
                <td>SQLite</td>
                <td>PDO::sqliteCreateFunctionに対応し、INパラメータにおいてサポートしています。</td>
            </tr>
            <tr>
                <td>Firebird</td>
                <td>現在利用不可です。</td>
            </tr>
            <tr>
                <td>Sybase</td>
                <td>現在利用不可です。</td>
            </tr>
        </table>
    </ul>

    <h4><a name="diconfile">diconファイル</a></h4>

        <p>diconファイルはDaoをコンテナにコンポーネント登録します。
        Dao機能を使用するには、登録したDaoに対して、AOPを適用する必要があります。
        diconファイルはどこに配置してもいいのですが、通常Daoと同じ場所に配置します。
        diconファイルの詳しい設定方法については、<a href="http://s2container.php5.seasar.org/DIContainer.html">DIContainer</a>を参照して下さい。</p>

    <h5>S2DaoInterceptorの適用</h5>

        <p>Dao機能を使用するには "org.seasar.dao.interceptors.S2DaoInterceptor"を登録したDaoに対してAOPを適用します。<br />
        AOPについては、<a href="http://s2container.php5.seasar.org/aop.html">AOP</a>のページを参照して下さい。<br />
        以下はDao(EmployeeDao)をコンポーネント登録するサンプル</p>
        <p>EmployeeDao.dicon</p>

<pre>
&lt;components&gt;
    &lt;include path="dao.dicon"/&gt;
    &lt;component class="EmployeeDao"&gt;
        &lt;aspect&gt;dao.interceptor&lt;/aspect&gt;
    &lt;/component&gt;
&lt;/components&gt;
</pre>

        <p>dao.dicon</p>

<pre>
&lt;components namespace="dao"&gt;
    &lt;include path="%PDO_DICON%" /&gt;
    &lt;component class="S2Dao_FieldAnnotationReaderFactory" /&gt;
    &lt;component class="S2Dao_DaoMetaDataFactoryImpl" /&gt;
    &lt;component name="interceptor" class="S2DaoInterceptor" /&gt;
&lt;/components&gt;
</pre>

        <p>pdo.dicon</p>

<pre>
&lt;components namespace="pdo"&gt;
    &lt;component name="dataSource" class="S2Container_PDODataSource"&gt;
        &lt;property name="dsn"&gt;"mysql:host=localhost; dbname=s2con"&lt;/property&gt;
        &lt;property name="user"&gt;"root"&lt;/property&gt;
        &lt;property name="password"&gt;"pass"&lt;/property&gt;
    &lt;/component&gt;
&lt;/components&gt;
</pre>

        <p>&lt;component class="S2Dao_DaoMetaDataFactoryImpl"/&gt;はS2DaoInterceptorのコンストラクタの引数となるので、
         S2Dao_DaoMetaDataFactoryImplも記述しておきます。</p>

    <h4><a name="SQLfile">SQLファイル</a></h4>

        <p>検索、更新処理等を行うSQL文を記述します。
        Daoに定義したメソッドを呼び出すと、対応するSQLファイルに記述されているSQL文が発行されます。
        作成したSQLファイルはDaoと同じ場所に配置してください。<br />
        ※S2DaoにはSQLを<a href="#AutoUpdate">自動で生成する機能</a>が用意されているので、SQLファイルがない場合、S2Dao.PHP5がSQL文を自動生成します。</p>

    <h5>SQLファイル名</h5>

        <p>S2DaoにはSQLのファイル名にも命名規則があります。</p>

        <ul>
            <li>SQLファイルとDaoに定義したメソッドの関連付け</li>
            <p>作成したSQLファイルとDaoに定義したメソッドの関連付けをするには、SQLファイルのファイル名を以下の形式にする必要があります。</p>
            <p> -  <span class="italic">Daoのクラス名</span>_<span class="italic">メソッド名</span>.sql</p>
            <p>examples.dao.EmployeeDao::getAllEmployeesList()に対応するSQLファイルは以下のようになります。</p>
            <pre>examples/dao/EmployeeDao_getAllEmployeesList.sql</pre>

            <li>複数DBMS対応</li>
                <p>DBMSごとに使用するSQLファイルを指定することができます。<br />
                どのDBMSを使っているのかは PDO::ATTR_DRIVER_NAME の値に応じて、S2Dao が自動的に判断しています。<br />
                S2Dao.PHP5でDBMSごとにサフィックスを決めているので、SQLファイル名にサフィックスを追加します。<br />
                例えば MySQL の場合、サフィックスは mysql なので、「EmployeeDao_getAllEmployeesList_mysql.sql」というファイル名になります。</p>

            <p>DBMSとサフィックスの関係は以下の通りです。</p>
            <table border="1" class="main">
                <tr bgcolor="#d1f3f4" align="center">
                    <th scope="col">DBMS</th>
                    <th scope="col">サフィックス</th>
                </tr>
                <tr>
                    <td>Oracle</td>
                    <td>oracle</td>
                </tr>
                <tr>
                    <td>Firebird</td>
                    <td>firebird</td>
                </tr>
                <tr>
                    <td>MySQL</td>
                    <td>mysql</td>
                </tr>
                <tr>
                    <td>PostgreSQL</td>
                    <td>pgsql</td>
                </tr>
                <tr>
                    <td>SQLite</td>
                    <td>sqlite</td>
                </tr>
                <tr>
                    <td>Sybase</td>
                    <td>sybase</td>
                </tr>
            </table>
        </ul>

    <h5>SQL文の記述</h5>

        <p>SQLファイルには、”SELECT * FROM EMP”, “DELETE FROM EMP WHERE EMPNO = 7788”といった、普通のSQL文を記述することが可能です。<br />
        また、WHERE句の条件の値などを動的に変化させることも可能です。
        詳しくは、<a href="#SQLbind">SQLコメント</a>を参照して下さい。</p>

    <h3><a name="SQLBind">SQLコメント</a></h3>

        <p>S2Dao.PHP5では、メソッドの引数とSQL文のバインド変数の対応付けを/**/や--などのコメントを使って行います。
        コメントなので、対応付けをした後でも、SQL*PlusなどのSQLのツールでそのまま実行することができます。
        最初、SQLのツールでSQL文を実行して思い通りの結果を出力するようになったら、
        それに対して、コメントを埋め込んでいくと良いでしょう。</p>

        <p>また、SQL文に対しての説明の意味でのコメントを使用したい場合は、/*の後にスペースを入れることにより、
        普通のコメントを使用することが出来ます。例として、/* hoge*/となります。/*の後にスペースが入っているので、実行時には無視されます。</p>

    <h4>バインド変数コメント</h4>

        <p>Daoに定義したメソッドの引数の値をSQL文で使用する場合は、SQL文にバインド変数コメントを記述します。
        バインド変数コメントの右側のリテラルに引数の値が自動的に置換され実行されます。
        バインド変数コメントは、以下のように記述します。</p>
        <p>-  /*<span class="italic">引数名</span>*/<span class="italic">リテラル</span></p>

        <p>引数がEntityの場合は以下のように記述します。</p>
        <p>-  /*<span class="italic">引数名</span>.<span class="italic">プロパティ名</span>*/<span class="italic">リテラル</span></p>

        <pre>public function getEmployeeList($empno);</pre>

        <p>Daoに上記のメソッドを定義した場合、SQLファイル(EmploeeDao_getEmployeeList.sql)は次のようにバインド変数を使用することが可能です。
        自動的にgetEmployeeListメソッドの引数の値が設定されます。</p>
        <pre>SELECT * FROM emp WHERE empno = /*empno*/7788</pre>

        <p>IN句にバインド変数を適用したい場合は以下のようにすることができます。</p>
        <p>-  IN /*<span class="italic">引数名</span>*/(...)</p>
        <pre>IN /*names*/('aaa', 'bbb')</pre>
        <p>引数はjava.util.Listや配列の引数となります。上記のIN句の場合は、以下のように引数を用意します。</p>
        <pre>$names = array("SCOTT", "SMITH", "JAMES");</pre>
        <p>配列namesが自動的にバインド変数の部分に置換されます。</p>

        <p>LIKEを使用する場合は、次のようにします。</p>
        <pre>ename LIKE /*ename*/'hoge'</pre>

        <p>ワイルドカードを使いたい場合は、メソッドの引数の値に埋め込みます。
        「"COT"を含む」という条件を指定する場合は、以下のように引数の値にワイルドカードを埋め込みます。</p>
        <pre>$employeeDao-&gt;findEmployees("%COT%");</pre>

    <h4>埋め込み変数コメント</h4>

        <p>Daoに定義したメソッドの引数の値をSQL文に文字列として直接埋め込む場合は、SQL文に埋め込み変数コメントを記述します。
        埋め込み変数コメントの右側のリテラルに引数の値が自動的に置換され実行されます。
        埋め込み変数コメントは、以下のように記述します。</p>
        <p>-  /*<span class="italic">引数名</span>*/<span class="italic">リテラル</span></p>

        <p>引数がEntityの場合は以下のように記述します。</p>
        <p>-  /*<span class="italic">引数名</span>.<span class="italic">プロパティ名</span>*/<span class="italic">リテラル</span></p>

    <h4>IFコメント</h4>

        <p>IFコメントでは、条件に応じて実行するSQL文を変えることが可能です。IFコメントは以下の形式で記述します。</p>

        <p> -  /*IF <span class="italic">条件</span>*/ .../*END*/</p>
        <p>サンプルは以下のとおりです。</p>
        <pre>/*IF hoge != null*/hoge = /*hoge*/'abc'/*END*/</pre>

        <p>IFコメントは、条件が真の場合、/*IF*/と/*END*/に囲まれた部分が評価されます。
        上記の場合、引数 hoge がnullでない場合にのみ、IFコメントで囲まれている部分(hoge = /*hoge*/'abc')が評価されます。<br />
        また偽の場合の処理としてELSEコメントというものが用意されています。
        条件が偽となった場合は、”ELSE”の後に記述した部分が評価されます。ELSEコメントは以下のように記述します。</p>

<pre>
/*IF hoge != null*/hoge = /*hoge*/'abc'
  --ELSE hoge is null
/*END*/
</pre>

        <p>条件がfalseになると--ELSEの後の部分(hoge is null)が評価されます。</p>

        <p>※/*IF hoge != null*/の判別を厳密に行いたい(型も含める)場合は /*IF hoge !=== null*/を使用してください。<br />
        例えば hoge = "true" の場合以下のIFコメントでは動作が違います。</p>
<pre>
/*IF hoge == true*/hoge = 123/*END*/
/*IF hoge == "true"*/hoge = 456/*END*/
/*IF hoge === true*/hoge = 789/*END*/
/*IF hoge === "true"*/hoge = 823/*END*/
</pre>

    <h4>BEGINコメント</h4>

        <p>BEGINコメントは、WHERE句内のすべてのELSEを含まないIFコメントがfalseになった場合に、
         WHERE句自体を出力したくない場合に使います。BEGINコメントはIFコメントと併せて使用します。<br />
        BEGINコメントは以下の形式で記述します。</p>
        <p>- /*BEGIN*/<span class="italic">WHERE句</span>/*END*/</p>

        <p>サンプルは以下の通りです。</p>

<pre>
/*BEGIN*/WHERE
  /*IF job != null*/job = /*job*/'CLERK'/*END*/
  /*IF deptno != null*/AND deptno = /*deptno*/20/*END*/
/*END*/
</pre>

        <p>上記の場合、job,deptnoがnullの場合は、WHERE句は出力されません。
        job == null,deptno != nullの場合は、WHERE depno = ?、 job != null,deptno == nullの場合は、WHERE job = ?、
        job != null,deptno != nullの場合は、WHERE job = ? AND depno = ?のようになります。動的SQLも思いのままです。</p>

    <h3><a name="EntityManager">EntityManagerを使用したQueryの実行</a></h3>

        <p>EntityManagerを使用し、自動的に生成されるSELECT文にWHERE句やORDER BY句を追加できます。書き方は、<a href="#QueryAnnotation">QUERYアノテーション</a>と同様です。
        主に、動的にQueryを組み立てたいときに使用します。EntityManagerを使用するには、以下のクラスを継承します。</p>

        <p>- S2Dao_AbstractDao</p>

        <p>Daoのインターフェース名は、必ず"Dao"で終わるようにしてください。S2Daoは、S2Dao_AbstractDaoを継承したクラスが実装しているインターフェースの中で、
        クラス名が"Dao"で終わっているインターフェースをDaoインターフェースだと判断しているためです。</p>

        <p>EntityManagerには、以下のメソッドが用意されています。</p>

        <dl>
            <dt style="text-indent:1em;">find()メソッド</dt>
            <dd>戻り値をS2Dao_ArrayList(ArrayObject)で返します。引数の種類は以下の通りです。<br />
            public function find($query, $arg1 = null, $arg2 = null, $arg3 = null);<br />
            </dd>

            <dt style="text-indent:1em;">findArray()メソッド</dt>
            <dd>戻り値を配列(array())で返します。引数の種類は以下の通りです。<br />
            public function findArray($query, $arg1 = null, $arg2 = null, $arg3 = null);<br />
            </dd>

            <dt style="text-indent:1em;">findBean()メソッド</dt>
            <dd>戻り値をEntity(Bean)で返します。引数の種類は以下の通りです。<br />
              public function findBean($query, $arg1 = null, $arg2 = null, $arg3 = null);<br />
            </dd>

            <dt style="text-indent:1em;">findObject()メソッド</dt>
            <dd>結果セットを Entity オブジェクトで返します。引数の種類は以下の通りです。<br />
            public function findObject($query, $arg1 = null, $arg2 = null, $arg3 = null);<br />
            </dd>

            <dt style="text-indent:1em;">findYaml()メソッド</dt>
            <dd>結果セットを YAML 形式で返します。引数の種類は以下の通りです。<br />
            public function findYaml($query, $arg1 = null, $arg2 = null, $arg3 = null);<br />
            </dd>

            <dt style="text-indent:1em;">findJson()メソッド</dt>
            <dd>結果セットを JSON 形式で返します。引数の種類は以下の通りです。<br />
            public function findJson($query, $arg1 = null, $arg2 = null, $arg3 = null);<br />
            </dd>
        </dl>

        <p>引数は、QUERYアノテーションと同様に記述します。引数が4つ以上になるの場合は、配列(array)を使用します。</p>

    <h4>S2Dao_AbstractDaoを継承したクラスの基本的な実装方法</h4>

        <ol>
            <li>S2Dao_AbstractDaoの継承</li>
            <li>Daoをimplementsする<br />
                implementsするDaoのインターフェース名の最後は"Dao"で終了している必要があります。</li>
            <li>コンストラクタの実装<br />
                S2Dao_DaoMetaDataFactoryを引数とし、parent::__construct(S2Dao_DaoMetaDataFactory)を呼び出します。</li>
            <li>Daoに定義したメソッドの実装<br />
                EntityManagerで提供しているメソッドを使用する場合は、<span class="italic">$this-&gt;getEntityManager()-&gt;find(...);</span>のように、getEntityManager()メソッドを使用し、
                EntityManagerを取得し呼び出すことが出来ます。</li>
        </ol>

        <p>S2Dao_AbstractDaoを継承したクラスのサンプルは以下の通りです。</p>

<pre>
class Employee2DaoImpl extends S2Dao_AbstractDao implements Employee2Dao {

    public function __construct(S2Dao_DaoMetaDataFactory $daoMetaDataFactory) {
        parent::__construct($daoMetaDataFactory);
    }

    public function getEmployeesList($ename) {
        return $this-&gt;getEntityManager()-&gt;find("ename LIKE ?", "%" + $ename + "%");
    }
}
</pre>

    <h3><a name="VersionNo">VersionNoによる排他制御 </a></h3>
        <p>S2Dao.PHP5は排他制御も自動的に行うことができます。<br />
        設定方法は、テーブルに排他制御用のカラムを用意し、Entity(Bean)に$versionNoと定義するだけで、versionNoによる排他制御を自動的に行ってくれます。</p>
        <p>例えば、2人のユーザがversionNo値0の同一データを取得して更新しようとした場合、
        先に更新したユーザは正常に登録することができます。そのとき自動でversionNoはインクリメントされ、DBのversionNoは1となります。
        次にもう１人のユーザがデータを更新しようとすると、ユーザが保持しているversionNoの値(0)と、
        実際にDB格納されているversionNoの値(1)が異なることになり、UpdateFailureRuntimeExceptionが発生し更新失敗することになります。</p>

    <h3><a name="Timestamp">Timestampによる排他制御 </a></h3>
        <p>VersionNoの他にTimestampによる排他制御もS2Dao.PHP5が自動的に行うことができます。Entity(Bean)に$timestampという名前のプロパティを定義するだけで、自動的に行ってくれます。
        Timestamp用のカラムの値にnullが設定されていると比較に失敗するので注意してください。</p>

    <h3><a name="AutoUpdate">更新SQLの自動生成</a></h3>

        <p>更新SQL文を自動生成させるには、メソッド名を<a href="#DefMethod">命名規則</a>にあわせ、Entityを1つ引数に持つメソッドを定義するだけです。
        SQLファイルの作成は不要です。例としてInsertの場合、命名規則に合わせ、以下のように定義します。</p>
        <pre>public function insert(Department $department);</pre>

    <h3><a name="AutoSelect">検索SQLの自動生成</a></h3>

        <p>メソッドのsignatueより、S2Dao.PHP5に自動的にSELECT文を生成させることもできます。ARGSアノテーションにカラム名を指定することで、
        引数の値によってWHERE句が変わるような動的なSQL文も自動生成できます。</p>

<pre>
SELECT * FROM emp
/*BEGIN*/WHERE
  /*IF job != null*/job = /*job*/'CLERK'/*END*/
  /*IF deptno != null*/AND deptno = /*deptno*/20/*END*/
/*END*/
</pre>

        <p>上記SQL文に相当するSQL文を自動生成するには以下のように定義します。上記SQLの/**/などについては、<a href="#SQLBind">SQLコメント</a>を参照してください。</p>
        <pre>const getEmployeeByJobDeptnoList($job, $deptno);</pre>

        <p><a href="#N1Mapping">N:1でマッピング</a>されているカラムを指定する場合には、「カラム名_関連番号」で指定します。
        N:1でマッピングされているBeanは左外部結合を使って1つのSQL文で取得されます。左外部結合をサポートしていないRDBMSはSELECT文自動生成の対象外です。
        オラクルのように左外部結合が標準と異なる場合も、S2Dao.PHP5がRDBMSがオラクルであると自動的に判断して適切なSQL文を組み立てます。</p>

        <p>引数にDTO（Data Transter Object）を指定することもできます。その場合、ARGSアノテーションを指定してはいけません。
        S2Dao.PHP5は、引数が1つで、ARGSアノテーションが指定されていない場合、引数をDTOとみなし、DTOのプロパティを使って自動的にSQL文を組み立てます。
        プロパティ名とカラム名が異なる場合は、COLUMNアノテーションを使ってカラム名を指定します。N:1でマッピングされているカラムを指定する場合には、カラム名_関連番号で指定します。
        テーブルに存在しないプロパティ(カラム)は自動的に無視されます。プロパティの値によって、WHERE句が変わるような動的SQL文を自動生成します。<br />
        動的SQL文の自動生成とORDER BYではじまるQUERYアノテーションは併用することが出来ます。</p>

<pre>
class EmployeeSearchCondition {

    const dname_COLUMN = "dname_0";
    private $job;
    private $dname;
    ...
}
</pre>

<pre>getEmployeesBySearchConditionList(EmployeeSearchCondition $dto);</pre>

        <p>また同様の指定方法で引数にEntityを使用することも出来ます。<br />
        DTOの詳しい使用方法は、<a href="example.html#AutoSelectExample">自動で検索用SQL文を生成する場合のExample</a>を参照して下さい。</p>

    <h3><a name="Annotation">定数アノテーションとコメントアノテーション</a></h3>

        <p>S2Dao.PHP5では定数アノテーションの他にコメントアノテーションにも対応しています。<br />
        コメントアノテーションを利用することで、メソッド名に余計な文字列(List、Array)を付けなくて済みます。</p>

        <p>コメントアノテーションを利用するにおいては、S2Container.PHP5-1.1.0以降を必要とします。<br />
        また、現在コメントアノテーションと定数アノテーションを同時に使用することはできません。</p>

        <p>コメントアノテーションを使用する方法は以下のようになります。</p>
        <ol>
            <li>DaoおよびEntity(Bean)にコメントアノテーションを設定</li>
            <li>作成したファイル実行する</li>
        </ol>

    <h4>定数 'S2DAO_PHP5_USE_COMMENT' の設定</h4>
        <p>コメントアノテーションを使用するにあたってS2DAO_PHP5_USE_COMMENTの定数に true を代入しておく必要があります。</p>
<pre>
define('S2DAO_PHP5_USE_COMMENT', true);
</pre>
        <p>define('S2DAO_PHP5_USE_COMMENT', true);は必ずbooleanを指定してください</p>

    <h4>DaoおよびEntity(Bean)にコメントアノテーションを設定</h4>
        <p>各コメントアノテーションをDao及びEntity(Bean)に設定します。</p>

    <h5>Daoに設定する場合のサンプル</h5>
<pre>&lt;?php

/**
 * @Dao(bean = CdBean)
 */
interface CdDao {

    /**
     * @NoPersistentProperty("id, content")
     */
    public function update(CdBean $cd);

    /**
     * @NoPersistentProperty("content")
     */
    public function insert(CdBean $cd);

    /**
     * @return array
     */
    public function getAll();

    /**
     * @Sql("SELECT CD.ID, CD.TITLE FROM CD WHERE ID > 1")
     * @return array
     */
    public function getCds();

    /**
     * @return list
     */
    public function getCD1($id, $title = null);

    /**
     * @Sql("SELECT COUNT(*) FROM CD")
     * @return object
    */
    public function getCdCount();
}
?&gt;</pre>

    <h5>Entity(Bean)に設定する場合のサンプル</h5>

<pre>&lt;?php

/**
 * @Bean(table = CD)
 */
class CdBean {

    /**
     * @Column(ID)
    */
    private $id;

    /**
     * @Ccolumn(TITLE)
    */
    private $title;

    /**
     * @Column(CONTENT)
    */
    private $content;

    public function getContent() {
        return $this-&gt;content;
    }

    public function setContent($content) {
        $this-&gt;content = $content;
    }

    public function getId() {
        return $this-&gt;id;
    }

    public function setId($id) {
        $this-&gt;id = $id;
    }

    public function getTitle() {
        return $this-&gt;title;
    }

    public function setTitle($title) {
        $this-&gt;title = $title;
    }
}
?&gt;</pre>

    <h4>作成したファイル実行する</h4>
        <p>作成したファイルを読み込み、実行させます。</p>

<pre>&lt;?php
require_once dirname(__FILE__) . "/example.inc.php";

$container = S2ContainerFactory::create("./resource/example.dicon.xml");
$dao = $container->getComponent("CdDao");

$cd = $dao-&gt;getAll();

for($i = 0; $i &lt; count($cd); $i++){
    echo "ID: " . $cd[$i]-&gt;getId() . PHP_EOL;
    echo "TITLE: " . $cd[$i]-&gt;getTitle() . PHP_EOL;
    echo "CONTENT: " . $cd[$i]-&gt;getContent() . PHP_EOL;
    echo "-------" . PHP_EOL;
}

echo "=====" . PHP_EOL;

$list = $dao-&gt;getCD1(2, 'aaa');
for($i = 0; $i &lt; $list-&gt;size(); $i++){
    $cd = $list-&gt;get($i);
    echo "ID: " . $cd-&gt;getId() . PHP_EOL;
    echo "TITLE: " . $cd-&gt;getTitle() . PHP_EOL;
    echo "CONTENT: " . $cd-&gt;getContent() . PHP_EOL;
    echo "-------" . PHP_EOL;
}

?&gt;</pre>

    <h3><a name="HowToRun">S2Daoの実行</a></h3>

        <p>Daoを実行する基本的な方法は以下のようになります。</p>
        <ol>
            <li>作成したdiconファイルのパスを引数にS2Containerを生成</li>
            <li>生成したS2ContainerからgetComponentを呼び出し、登録したDaoを取得する </li>
            <li>取得したDaoのメソッドを実行する</li>
        </ol>

   <p> 実行サンプル</p>

<pre>
&lt;?php
define("PATH", "examples/dao/EmployeeDao.dicon");
define("PDO_DICON", "examples/pdo.dicon");

$container = S2ContainerFactory::create(PATH); /* 手順1 */
$dao = $container->getComponent("EmployeeDao"); /* 手順2 */
var_dump($dao->List_getAllEmployee(7788)); /* 手順3 */
?&gt;
</pre>

<!-- document end -->
<!-- don't edit start -->
</td>
<td width="14"><img height="14" width="14" src="images/spacer.gif" alt=""></td>
</tr><tr>
<td width="14"><img height="30" width="14" src="images/spacer.gif" alt=""></td>
<td width="766"><img height="30" width="592" src="images/spacer.gif" alt=""></td>
</tr><tr>
<td width="14"><img height="14" width="14" src="images/spacer.gif" alt=""></td>
<td width="766" class="copyright">&copy; Copyright The Seasar Foundation and the others 2004-2005, all rights reserved.</td>

</tr></table>
<td class="backright" align="left" valign="top">&nbsp;</td></tr><tr>
<td class="backunder" align="left"  valign="top" width="780" height="16">&nbsp;</td>
<td class="backcorner" align="left" valign="top" height="16">&nbsp;</td>
</tr></table></body>
<!-- don't edit end -->
</html>