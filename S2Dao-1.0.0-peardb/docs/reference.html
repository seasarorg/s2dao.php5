<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<!-- don't edit start -->
<head><title>Seasar - DI Container with AOP - </title><meta http-equiv="Content-Type" content="text/html; charset=Shift_JIS">
<link href="seasar_b.css" type="text/css" rel="stylesheet"><script src="seasar_b.js" type="text/JavaScript" language="JavaScript"></script>
</head><body onload="preload('ja')"><table width="100%" border="0" cellspacing="0" cellpadding="0" align="left" height="100%"><tr>
<td align="left" valign="top" width="780"><table width="780" border="0" cellspacing="0" cellpadding="0" class="white">
<tr><td colspan="7"><img height="5" width="780" src="images/top01_b.gif" alt=""></td></tr>
<tr><td><img height="117" width="235" src="images/top02_b.gif" alt="Seasar"></td>
<td colspan="3"><img height="117" width="289" src="images/top03.gif" alt="DI Container with AOP"></td>
<td colspan="3"><img height="117" width="256" src="images/spacer.gif" alt=""></td>
</tr><tr><td rowspan="2"><img src="images/top04.gif" alt="" height="49" width="235"></td>
<td><a href="index.html"><img src="images/menu01_b_ja.gif" height="30" width="78" border="0" alt="" id="menu01" onmouseover="swap(1)" onmouseout="restore(1)"></a></td>
<td><a href="projects.html"><img src="images/menu02_b_ja.gif" height="30" width="101" border="0" alt="" id="menu02" onmouseover="swap(2)" onmouseout="restore(2)"></a></td>
<td><a href="products.html"><img src="images/menu03_b_ja.gif" height="30" width="110" border="0" alt="" id="menu03" onmouseover="swap(3)" onmouseout="restore(3)"></a></td>

<td><a href="resources.html"><img src="images/menu04_b_ja.gif" height="30" width="113" border="0" alt="" id="menu04" onmouseover="swap(4)" onmouseout="restore(4)"></a></td>
<td><img src="images/menu05_b_ja.gif" height="30" width="109" border="0" alt="" id="menu05" onmouseover="swap(5)" onmouseout="restore(5)"></td>
<td><img height="30" width="34" src="images/menu06.gif" alt=""></td></tr><tr>
<td colspan="6"><img height="19" width="545" src="images/spacer.gif" alt=""></td></tr></table>
<table  width="780" border="0" cellspacing="0" cellpadding="0" height="100%" class="white">
<tr align="left" valign="top"><td width="14"><img height="14" width="14" src="images/spacer.gif" alt=""></td><td width="752" class="main">
<!-- don't edit end -->
<!-- document start -->

    <ul>
        <li><a href="#reference">S2Daoリファレンス</a>
            <ul>
                <li><a href="#DaoMakeFile">作成すべきファイル</a></li>
                    <ul>
                        <li type="circle"><a href="#Beans">Beans</a></li>
                            <ul>
                                <li><a href="#TableAnnotation">TABLEアノテーション</a></li>
                                <li><a href="#ColumnAnnotation">COLUMNアノテーション</a></li>
                                <!-- <li><a href="#N1Mapping">N:1マッピング</a></li> -->
                                <!-- <li><a href="#IDAutoGenerate">IDの自動生成</a></li> -->
                                <!-- <li><a href="#NoPersistentColumns">永続化されないカラム</a></li> -->
                                <!-- <li><a href="#VersionNoPropertyAnnotation">VERSION_NO_PROPERTYアノテーション</a></li> -->
                                <!-- <li><a href="#TimestampPropertyAnnotation">TIMESTAMP_PROPERTYアノテーション</a></li> -->
                                <li><a href="#property">カラムに対応するプロパティの宣言</a></li>
                                <li><a href="#GetterSetterMethod">getter/setterメソッドの実装</a></li>
                            </ul>
                        <li type="circle"><a href="#Dao">Dao(Data Access Object)</a></li>
                            <ul>
                                <li><a href="#BeanAnnotation">BEANアノテーション</a></li>
                                <li><a href="#ArgsAnnotation">ARGSアノテーション</a></li>
                                <!-- <li><a href="#QueryAnnotation">QUERYアノテーション</a></li>-->

                                <li><a href="#DefMethod">メソッドの定義</a></li>
                                <li><a href="#NoPersistentPropsAnnotation">NO_PERSISTENT_PROPSアノテーション</a></li>
                                <li><a href="#PersistentPropsAnnotation">PERSISTENT_PROPSアノテーション</a></li>
                                <li><a href="#SqlAnnotation">SQLアノテーション</a></li>
                            </ul>
                        <li type="circle"><a href="#diconfile">diconファイル</a></li>

                        <li type="circle"><a href="#SQLfile">SQLファイル</a></li>
                    </ul>
                <li><a href="#SQLBind">SQLコメント</a></li>
                <li><a href="#AutoUpdate">更新SQLの自動生成</a></li>
                <li><a href="#AutoSelect">検索SQLの自動生成 </a></li>
                <li><a href="#IDAutoGenerate">IDの自動生成 </a></li>
                <li><a href="#HowToRun">S2Daoの実行</a></li>
            </ul>
        </li>
    </ul>

    <h1><a name="reference">S2Dao.PHP5リファレンス</a></h1>

    <h3><a name="DaoMakeFile">作成すべきファイル</a></h3>
        <p>S2Dao機能を使用するにあたり、Beans、Dao(.php)、diconファイル、SQLファイル(.sql)の作成が必要となります。
        <br />各ファイルの関連イメージ図は次のようになります。</p>

        <img src="./images/dao_relation_image.gif"/>
        <p>Beansはテーブル、DaoはBeans、diconファイルはDao、SQLファイルはDaoとそれぞれ関連しています。<br />
        各ファイルの実装・設定方法の詳細は次のようになります。</p>

    <h4><a name="Beans">Beans</a></h4>
        <p>
        Beansはテーブルとの関連付けに使用します。
        Beansにテーブルの関連付けを行うには、以下の定数宣言とメソッドの実装が必要になります。</p>

        <ul>
        <li>テーブルとの関連付けの定数宣言 (<a href="#TableAnnotation">TABLEアノテーション</a>)</li>
        <!-- <li>カラムとの関連付けの定数宣言 (<a href="#ColumnAnnotation">COLUMNアノテーション</a>)</li> -->
        <!-- <li>別テーブルと結合する場合はキーとなる定数宣言 (<a href="#N1Mapping">N:1マッピング</a>)</li>-->
        <!-- <li><a href="#IDAutoGenerate">IDの自動生成</a></li> -->
        <li><a href="#NoPersistentColumns">永続化されないカラム</a></li>
        <li><a href="#property">カラムに対応するプロパティの宣言</a><il>
        <li><a href="#GetterSetterMethod">getter/setterメソッドの実装</a></li>
        </ul>

        <p>Beansの構成と説明内で使用するテーブルは以下の通りです。</p>
        テーブル：EMP<br />
        <table border="1" class="main">
            <tr bgcolor="#d1f3f4" align="center">
              <th>カラム名</th>
              <th>型</th>
              <th>NotNull</th>

              <th>主キー</th>
            </tr>
            <tr>
              <td>EMPNO</td>
              <td>NUMBER</td>
              <td align="center">〇</td>
              <td align="center">〇</td>

            </tr>
            <tr>
              <td>ENAME</td>
              <td>VARCHAR</td>
              <td>&nbsp;</td>
              <td>&nbsp;</td>
            </tr>
            <tr>

              <td>DEPTNUM</td>
              <td>NUMBER</td>
              <td>&nbsp;</td>
              <td>&nbsp;</td>
            </tr>
        </table>
       <br />
        テーブル：DEPT<br />

        <table border="1" class="main">
            <tr bgcolor="#d1f3f4" align="center">
              <th>カラム名</th>
              <th>型</th>
              <th>NotNull</th>
              <th>主キー</th>
            </tr>

            <tr>
              <td>DEPTNO</td>
              <td>NUMBER</td>
              <td align="center">〇</td>
              <td align="center">〇</td>
            </tr>
            <tr>

              <td>DNAME</td>
              <td>VARCHAR</td>
              <td>&nbsp;</td>
              <td>&nbsp;</td>
            </tr>
        </table>
    <h5><a name="TableAnnotation">TABLEアノテーション</a></h5>

        <p>テーブルとの関連付けはTABLEアノテーションを使用します。
        TABLEアノテーションは以下の形式で定数を宣言します。</p>
        <p> -  const TABLE = “<span class="italic">テーブル名</span>”;</p>
        <p>EMPテーブルの場合以下のようになります。</p>
        <pre>const TABLE = "EMP";</pre>

        <!--
        <p>スキーマの定義をすることも可能です。スキーマ名が"SCOTT"の場合は以下のようになります。</p>
        <pre>public static final String TABLE = "SCOTT.EMP";</pre>
        ※クラス名からパッケージ名を除いた名前がテーブル名と一致する場合は、TABLEアノテーションを定義する必要はありません。
        -->
     <!--
     <h5><a name="ColumnAnnotation">COLUMNアノテーション</a></h5>
        <p>テーブルのカラムとの関連付けはCOLUMNアノテーションを使用します。<br />
        COLUMNアノテーションは以下の形式で定数を宣言します。</p>
        <p> -  const <span class="italic">プロパティ名</span>_COLUMN = "<span class="italic">カラム名</span>";</p>

        employeeNoというプロパティにEMPNOカラムを関連付けする場合以下のようになります。
        <pre>const employeeNo_COLUMN = "EMPNO";</pre>
        ※プロパティ名とカラム名が一致する場合は、COLUMNアノテーションを定義する必要はありません。
        テーブルに存在しないプロパティは、自動的に無視されるので、特に何か定義する必要はありません。

     <h5><a name="N1Mapping">N:1マッピング</a></h5>
         <p>N:1マッピングとは、複数の従業員の行に1つの部署の行が関連付けられるような場合のマッピングです。<br />
         N:1マッピングを使用するには、RELNO定数とRELKEYS定数をそれぞれ宣言する必要があります。<br />
         RELNO定数は以下の形式になります。</p>

        <p> - const <span class="italic">プロパティ名</span>_RELNO = <span class="italic">数値</span>;</p>
        <p>RELNO定数は、N:1マッピングの連番です。<br />
        例えば、AAAのテーブルにBBB,CCCのテーブルがN:1マッピングされるとするとBBBのRELNOは0、CCCのRELNOは1になります。 <br />
        RELNOは結果セットに含まれているカラムが、どのテーブルに所属しているのかを判定することに使われます。<br />
        例えば、SELECT ..., BBB.HOGE AS HOGE_0, ... FROM AAA, BBB ...のようなSELECT文があった場合、 HOGE_0はBBBテーブルに含まれているHOGEカラムであると認識されます。<br />

        RELKEYS定数は以下の形式になります。</p>
        <p> - const <span class="italic">プロパティ名</span>_RELKEYS = "<span class="italic">N側のテーブルのカラム名: 1側のテーブルのカラム名</span>";</p>
        <p>N:1マッピングのキーはRELKEYS定数で指定します。
        キーが複数ある場合には、カンマ( , )で区切ります。例えば、mykey1:yourkey1, mykey2:yourkey2のようにします。<br />
        EMPテーブルのDEPTNUMカラムとDEPTテーブルのDEPTNOを関連付ける場合は以下のようになります。</p>
<pre>
const department_RELNO = 0;
const department_RELKEYS = "DEPTNUM:DEPTNO";
</pre>
        <p>1側のテーブルのカラム名がN側のテーブルのカラム名に等しい場合は、1側のテーブルのカラム名を省略することができます。
        その場合以下のように定義することが出来ます。</p>
<pre>const department_RELKEYS = "DEPTNO";</pre>
        <p>また1側のテーブルのカラム名とN側のテーブルのカラム名に等しく、1側のテーブルのカラム名がプライマリーキーの場合、RELKEYS定数を省略することができます。</p>

    <h5><a name="IDAutoGenerate">IDの自動生成</a></h5>
    <p>ID(プライマリーキー)をRDBMSに自動生成させて、自動生成された値をBeanに自動的に設定することが出来ます。そのために使うのが、IDアノテーションです。IDアノテーションは、プロパティ名_ID = &quot;identity&quot;のように指定します。 </p>

<pre>const id_ID = "identity";</pre>
    <p>SEQUENCEを使うことも出来ます。myseqの部分は、実際のSEQUENCEに置き換えてください。</p>
<pre>const id_ID = "sequence, sequenceName=myseq";</pre>
    <p>手動でIDを設定する場合は、何も指定する必要がありません。テーブルのプライマリーキーだという情報は、テーブルの定義(JDBCのメタデータ)より自動的に取得されます。また、明示的にassignedを指定することもできます。</p>
<pre>const id_ID = "assigned";</pre>

    <h5><a name="NoPersistentColumns">永続化されないカラム</a></h5>

    <p>カラムが永続化の対象かどうかという情報は、テーブルの定義(JDBCのメタデータ)より自動的に取得されます。また、明示的にNO_PERSISTENT_PROPSを使って永続化したくないカラムを指定することもできます。NO_PERSISTENT_PROPSに空文字を指定するとJDBCのメタデータのメタデータを使わずにすべてのプロパティを永続化の対象とみなします。</p>
<pre>const NO_PERSISTENT_PROPS = "dummy1, dummy2";</pre>

<h5><a name="VersionNoPropertyAnnotation">VERSION_NO_PROPERTYアノテーション</a></h5>
<p><a href="#VersionNo">versionNo</a>による排他制御用のプロパティ名をデフォルトのversionNoから変えるときに使うのがVERSION_NO_PROPERTYアノテーションです。次のように使います。</p>
<pre>const VERSION_NO_PROPERTY = "myVersionNo";</pre>

<h5><a name="TimestampPropertyAnnotation">TIMESTAMP_PROPERTYアノテーション</a></h5>

<p><a href="#Timestamp">timestamp</a>による排他制御用のプロパティ名をデフォルトのtimestampから変えるときに使うのがTIMESTAMP_PROPERTYアノテーションです。次のように使います。</p>
<pre>const TIMESTAMP_PROPERTY = "myTimestamp";</pre>
-->
    <h5><a name="property">カラムに対応するプロパティの宣言</a></h5>
        <p>テーブルのカラムに対応した変数を宣言します。</p>
        NUMBER型のEMPNOというカラムの場合、以下のように宣言することができます。

        <pre>private $empno;</pre>

     <h5><a name="GetterSetterMethod">getter/setterメソッド</a></h5>
        <p>テーブルのカラムに対応した各プロパティのgetter/setterメソッドを実装します。メソッドの命名規則は以下の形式になります。</p>
        getterメソッド
        <p> - public <span class="italic">function</span> get<span class="italic">プロパティ名</span>()</p>

        setterメソッド
        <p> - public function set<span class="italic">プロパティ名(引数)</span></p>
        private long empnoというプロパティの場合は以下のようになります。

<pre>private $empno;

public function getEmpno() {
    return $this-&gt;empno;
}

public function setEmpno($empno) {
    $this-&gt;empno = $empno;
}
</pre>
        <p>以上の設定を行ったEMPテーブルに関連付くBeansは次のようになります。</p>
<pre>
class Employee {
    const TABLE = "EMP";

    private $empno;

    private $ename;

    private $deptnum;

    private $department;

    public function Employee() {
    }

    public function getDepartment() {
        return $this-&gt;department;
    }

    public function setDepartment(Department $department) {
        $this-&gt;department = $department;
    }

    public function getDeptnum() {
        return $this-&gt;deptnum;
    }

    public function setDeptnum($deptnum) {
        $this-&gt;deptnum = $deptnum;
    }

    public function getEmpno() {
        return $this-&gt;empno;
    }

    public function setEmpno($empno) {
        $this-&gt;empno = $empno;
    }

    public function getEname() {
        return $this-&gt;ename;
    }

    public function setEname($ename) {
        $this-&gt;ename = $ename;
    }
}
</pre>

    <h4><a name="Dao">Dao(Data Access Object)</a></h4>

        <p>Daoはインターフェースとして作成します。永続化されるデータとロジックを分離して、Dao本来の目的であるBeanの永続化を行います。
        Beansとは1：1の関係にあるので、一つのBeansに対して一つのDaoを作成することになります。
        Daoのメソッドを呼ぶことにより、メソッドに対応したSQLファイルに記述されているSQLが実行されます。
        Daoを作成するには、以下の点が必要になります。</p>
        <ul>
            <li>Beansとの関連付けの定数宣言(<a href="#BeanAnnotation">BEANアノテーション</a>)</li>
            <li><a href="#DefMethod">メソッドの定義</a></li>
        </ul>
        <p>またメソッドの引数をSQL文で参照したり、WHERE句、ORDER句を追加、更新のSQLに含めない、あるいは含めるプロパティを指定する場合には、以下のアノテーションを使います。</p>

        <ul>
            <li><a href="#ArgsAnnotation">ARGSアノテーション</a></li>
            <!-- <li><a href="#QueryAnnotation">QUERYアノテーション</a></li> -->
            <li><a href="#NoPersistentPropsAnnotation">NO_PERSISTENT_PROPSアノテーション</a></li>
            <li><a href="#PersistentPropsAnnotation">PERSISTENT_PROPSアノテーション</a></li>
            <li><a href="#SqlAnnotation">SQLアノテーション</a></li>

        </ul>

    <h5><a name="BeanAnnotation">BEANアノテーション</a></h5>
        <p>DaoがどのBeans(エンティティ)に関連付けられているのかはBEANアノテーションで指定します。<br />
        BEANアノテーションは以下の形式で定数を宣言します。</p>
        <p> - const BEAN = "<span class="italic">Beans名</span>";</p>

        <p>EmployeeDaoクラスがEmployeeエンティティに関連付けられる場合は次のように定義します。  </p>
        <pre>const BEAN = "Employee";</pre>
    <h5><a name="ArgsAnnotation">ARGSアノテーション</a></h5>
        <p>メソッドの引数をSQL文で参照できるように、ARGSアノテーションを使用し、メソッドの引数名を指定します。メソッドの引数名は、リフレクションで取得できないためです。<br />
        ARGSアノテーションは以下の形式で定数を宣言します。</p>
        <p> - const <span class="italic">メソッド名</span>_ARGS = "<span class="italic">引数名</span>";</p>

         <p>public function List_getEmployee($empno)というメソッドがDaoに定義されていた場合の引数名は次のように定義します。</p>
        <pre>const List_getEmployee_ARGS = "empno";</pre>
        <p>メソッドの引数がテーブルのカラム名に対応している場合、<span class="italic">引数名</span>にはテーブルのカラム名を指定します。例えば、メソッドの引数名がempnoで、テーブルのカラム名がemployeenoの場合は、employeenoを指定するということです。
        引数が複数ある場合には、カンマで区切ります。引数が1つの場合、ARGSアノテーションは省略できます。</p>

<!--
    <h5><a name="QueryAnnotation">QUERYアノテーション</a></h5>
        <p>自動的に生成されるSELECT文にWHERE句やORDER BY句を追加するには、QUERYアノテーションを使用します。<br />

        QUERYアノテーションは以下の形式で定数を宣言します。</p>
        <p> - const <span class="italic">メソッド名</span>_QUERY = "<span class="italic">WHERE句ORDER BY句</span>";</p>
        <p>引数で給与の上限と下限を指定し、その間に含まれる従業員を抽出する場合、次のようにします。</p>
<pre>
const getEmployeesBySal_QUERY = "sal BETWEEN ? AND ? ORDER BY empno";

public function List_getEmployeesBySal($minSal, $maxSal);
</pre>
        <p>上記例の“?”をバインド変数と言います。バインド変数をQUERYアノテーションに記述することにより、メソッドの引数の値が順に”?”の部分に代入されます。
        ARGSアノテーションは、必要ありません。ORDER BY句だけを記述するときは、ORDER BYで始めてください。<a href="#SQLbind">SQLコメント</a>も記述することが出来ます。
        SQLコメントを使用したサンプルは以下のとおりです。
        </p>

<pre>const getEmployees_QUERY =
                      "job = /*job*/'CLERK'/*IF deptno != null*/ AND deptno = /*deptno*/20/*END*/";
</pre>
        <p>上記サンプルは、引数deptnoがnullでない場合、deptnoが引数の値と一致するという条件を追加します。SQLコメントについての詳しい説明は、<a href="#SQLbind">SQLコメント</a>の項目を参照して下さい。</p>
-->

    <h5><a name="DefMethod">メソッドの定義</a></h5>
        <p>Daoに定義したメソッドを呼ぶことにより、対応するSQLファイルに記述されているSQLが実行されますが、
        更新(INSERT, UPDATE, DELETE)、検索処理ごとにメソッドの命名規則があります。S2Daoではメソッドの命名規則よりSQL文の中身を自動的に決定しています。
        また、定義するメソッドのオーバーロードはサポートしていません。
        </p>
        <ul>
        <li>INSERT処理</li>

        <p>INSERT処理を行なうメソッドの名前が、insert,add,createではじまる必要があります。
        更新した行数が戻り値となります。引数の型はエンティティの型と一致させます。<br />
        メソッドの定義例は以下のようになります。</p>

<pre>public function insert(Department $department);
public function addDept(Department $department);
public function createDept(Department $department);
</pre>

        <li>UPDATE処理</li>
        <p>UPDATE処理を行うメソッドの名前が、update,modify,storeではじまる必要があります。
        更新した行数が戻り値となります。引数の型はエンティティの型と一致させます。<br />
        メソッドの定義例は以下のようになります。</p>

<pre>
public function update(Department $department);
public function modifyDept(Department $department);
public function storeDept(Department $department);
</pre>
        <li>DELETE処理</li>
        <p>DELETE処理を行うメソッドの名前が、delete,removeではじまる必要があります。
        intの場合、更新した行数が戻り値となります。引数の型はエンティティの型と一致させます。<br />
        メソッドの定義例は以下のようになります。</p>

<pre>
public function delete(Department $department);
public function removeDept(Department $department);
</pre>

        <li>検索(SELECT)処理</li>

        <p>検索処理を行ないたい場合は、メソッド名の最初が<span class="italic">List</span>または、<span class="italic">Array</span>である必要があります。</p>

        <p>Listで始まるメソッド名の場合は、SELECT文でエンティティのリスト(ArrayList形式)を返します。<br />
           以下のように記述することができます。(ArrayListはS2Dao.PHP5の組み込みクラスです。)</p>

<pre>
public function List_getEmp();
public function list_getEmp();
</pre>

        <p>Arrayで始まる場合は、エンティティ配列(ArrayObject)を返します。<br />
            以下のように記述することができます。(ArrayObjectはPHP5から導入されたSPLです。)</p>

<pre>
public function Array_getEmp();
public function array_getEmp();
</pre>

        </ul>

    <h5><a name="NoPersistentPropsAnnotation">NO_PERSISTENT_PROPSアノテーション</a></h5>
    <p>更新するときに、このプロパティは、SQLに含めて欲しくないという場合もあります。
    そのような場合は、NO_PERSISTENT_PROPSアノテーションを使います。</p>
    <pre>const insert_NO_PERSISTENT_PROPS = "sal, comm";</pre>
    <p>上記のように指定すると、insertメソッドで、salとcommプロパティは永続化の対象になりません。</p>

    <h5><a name="PersistentPropsAnnotation">PERSISTENT_PROPSアノテーション</a></h5>
    <p>更新するときに、このプロパティだけをSQLに含めたいという場合もあります。
    そのような場合は、PERSISTENT_PROPSアノテーションを使います。</p>

    <pre>const update_PERSISTENT_PROPS = "deptno";</pre>

    <p>上記のように指定すると、updateメソッドで、プライマリーキー、versionNo、timestampのプロパティに加えて、
    PERSISTENT_PROPSアノテーションで指定したプロパティが永続化の対象になります。</p>

    <h5><a name="SqlAnnotation">SQLアノテーション</a></h5>
    <p>SQLアノテーションを使用することが可能です。<br />
    機能はSQLファイルと同様で、アノテーションにてSQL及びSQLコメントを使用することが可能です。</p>

<!--
    <p>SQLアノテーションに命名規則があります。</p>
    <ul>
    <li>SQLファイルとDaoに定義したメソッドの関連付け</li>
    <p>SQLアノテーションとDaoに定義したメソッドの関連付けをするには、SQLアノテーションを以下の形式にする必要があります。</p>
    <p> - <span class="italic">メソッド名</span>_SQL</p>
    examples.dao.EmployeeDao#getAllEmployees()に対応するSQLアノテーションは以下のようになります。

<pre>public static final String getAllEmployees_SQL = "SELECT
emp.*, dept.dname dname_0, dept.loc loc_0 FROM emp, dept
 WHERE emp.deptno = dept.deptno ORDER BY emp.empno;";</pre>
-->
    <li>複数DBMS対応</li>
    <p>DBMSごとに使用するSQLアノテーションを指定することができます。
    どのDBMSを使っているのかはjava.sql.DatabaseMetadata#getDatabaseProductName()に応じて、S2Daoが自動的に判断しています。
    S2DaoのほうでDBMSごとにサフィックスを決めているので、SQLアノテーションにサフィックスを追加します。
    例えばオラクルの場合、サフィックスはoracleなので、「getAllEmployees_oracle_SQL」というSQLアノテーションになります。</p>
    DBMSとサフィックスの関係は以下の通りです。
    <table class="main" border="1">
        <tbody><tr align="center" bgcolor="#d1f3f4">
            <th scope="col">DBMS</th>
            <th scope="col">サフィックス</th>

        </tr>
        <tr>
            <td>Oracle</td>
            <td>oracle</td>
        </tr>
        <tr>
            <td>DB2</td>

            <td>db2</td>
        </tr>
        <tr>
            <td>MSSQLServer</td>
            <td>mssql</td>
        </tr>
        <tr>

            <td>MySQL</td>
            <td>mysql</td>
        </tr>
        <tr>
            <td>PostgreSQL</td>
            <td>postgre</td>
        </tr>

        <tr>
            <td>Firebird</td>
            <td>firebird</td>
        </tr>
        <tr>
            <td>SQLite</td>
            <td>sqlite</td>

        </tr>
    </tbody></table>
    </ul>

    <h4><a name="diconfile">diconファイル</a></h4>
        <p>diconファイルはDaoをコンテナにコンポーネント登録します。Dao機能を使用するには、登録したDaoに対して、AOPを適用する必要があります。
        diconファイルはどこに配置してもいいのですが、通常Daoと同じ場所に配置します。
        diconファイルの詳しい設定方法については、<a href="http://s2container.php5.sandbox.seasar.org/DIContainer.html">DIContainer</a>を参照して下さい。</p>
        <h5>S2DaoInterceptorの適用</h5>

        <p>Dao機能を使用するには"/org/seasar/dao/interceptors/S2DaoInterceptor"を登録したDaoに対してAOPを適用します。<br />
        AOPについては、<a href="http://s2container.php5.sandbox.seasar.org/aop.html">AOP</a>のページを参照して下さい。<br />
        以下はDao(example.dao.EmployeeDao)をコンポーネント登録するサンプル</p>

        <p>EmployeeDao.dicon</p>

<pre>
&lt;components&gt;
    &lt;include path="dao.dicon"/&gt;
    &lt;component class="EmployeeDao"&gt;
        &lt;aspect&gt;interceptor&lt;/aspect&gt;
    &lt;/component&gt;
&lt;/components&gt;
</pre>

        <p>dao.dicon</p>

<pre>
&lt;components namespace="dao"&gt;
    &lt;component name="dataSource" class="PearDBDataSource"&gt;
        &lt;property name="dsn"&gt;"mysql://root:pass@localhost/dbname"&lt;/property&gt;
    &lt;/component&gt;
    &lt;component class="PearDBSqlHandler"/&gt;
    &lt;component name="dbtx" class="PearDBTxInterceptor"/&gt;
    &lt;component name="session" class="DBSessionImpl"/&gt;
    &lt;component class="DaoMetaDataFactoryImpl"/&gt;
    &lt;component name="interceptor" class="S2DaoInterceptor"/&gt;
&lt;/components&gt;
</pre>

        <p>&lt;component class="DaoMetaDataFactoryImpl"/&gt;はS2DaoInterceptorのコンストラクタの引数となるので、
         DaoMetaDataFactoryImplも記述しておきます。<br />
         (※ S2Dao.PHP5 beta1 は PearDBDataSource のみサポートしています)</p>

        <h4><a name="SQLfile">SQLファイル</a></h4>
        <p>検索、更新処理等を行うSQL文を記述します。
        Daoに定義したメソッドを呼び出すと、対応するSQLファイルに記述されているSQL文が発行されます。
        作成したSQLファイルはDaoと同じ場所に配置してください。
        ※S2DaoにはSQLを<a href="#AutoUpdate">自動で生成する機能</a>が用意されているので、SQLファイルがない場合、S2DaoがSQL文を自動生成します。</p>
        <h5>SQLファイル名</h5>
        <p>S2DaoにはSQLのファイル名にも命名規則があります。</p>

        <ul>

        <li>SQLファイルとDaoに定義したメソッドの関連付け</li>
        <p>作成したSQLファイルとDaoに定義したメソッドの関連付けをするには、SQLファイルのファイル名を以下の形式にする必要があります。</p>
        <p> -  <span class="italic">Daoのクラス名</span>_<span class="italic">メソッド名</span>.sql</p>
        examples.dao.EmployeeDao#getAllEmployees()に対応するSQLファイルは以下のようになります。
        <pre>examples/dao/EmployeeDao_getAllEmployees.sql   </pre>

        <li>複数DBMS対応</li>
        <p>DBMSごとに使用するSQLファイルを指定することができます。
        どのDBMSを使っているのかはjava.sql.DatabaseMetadata#getDatabaseProductName()に応じて、S2Daoが自動的に判断しています。
        S2DaoのほうでDBMSごとにサフィックスを決めているので、SQLファイル名にサフィックスを追加します。
        例えばオラクルの場合、サフィックスはoracleなので、「EmployeeDao_getAllEmployees_oracle.sql」というファイル名になります。</p>
        DBMSとサフィックスの関係は以下の通りです。
        <table border="1" class="main">
            <tr bgcolor="#d1f3f4" align="center">
                <th scope="col">DBMS</th>
                <th scope="col">サフィックス</th>

            </tr>
            <tr>
                <td>Oracle</td>
                <td>oracle</td>
            </tr>
            <tr>
                <td>DB2</td>

                <td>db2</td>
            </tr>
            <tr>
                <td>MSSQLServer</td>
                <td>mssql</td>
            </tr>
            <tr>

                <td>MySQL</td>
                <td>mysql</td>
            </tr>
            <tr>
                <td>PostgreSQL</td>
                <td>postgre</td>
            </tr>

            <tr>
                <td>Firebird</td>
                <td>firebird</td>
            </tr>
            <tr>
                <td>SQLite</td>
                <td>sqlite</td>
            </tr>
        </table>
        </ul>

        <h5>SQL文の記述</h5>
        <p>SQLファイルには、”SELECT * FROM EMP”, “DELETE FROM EMP WHERE EMPNO = 7788”といった、普通のSQL文を記述することが可能です。
        また、WHERE句の条件の値などを動的に変化させることも可能です。詳しくは、<a href="#SQLbind">SQLコメント</a>を参照して下さい。</p>

        <h3><a name="SQLBind">SQLコメント</a></h3>

        <p>S2Daoでは、メソッドの引数とSQL文のバインド変数の対応付けを/**/や--などのコメントを使って行います。
        コメントなので、対応付けをした後でも、SQL*PlusなどのSQLのツールでそのまま実行することができます。
        最初、SQLのツールでSQL文を実行して思い通りの結果を出力するようになったら、
        それに対して、コメントを埋め込んでいくと良いでしょう。</p>

        <p>また、SQL文に対しての説明の意味でのコメントを使用したい場合は、/*の後にスペースを入れることにより、
        普通のコメントを使用することが出来ます。例として、/* hoge*/となります。/*の後にスペースが入っているので、実行時には無視されます。</p>

        <h4>バインド変数コメント</h4>
        <p>Daoに定義したメソッドの引数の値をSQL文で使用する場合は、SQL文にバインド変数コメントを記述します。
        バインド変数コメントの右側のリテラルに引数の値が自動的に置換され実行されます。
        バインド変数コメントは、以下のように記述します。</p>
        <p> -  /*<span class="italic">引数名</span>*/<span class="italic">リテラル</span></p>

        <!--
        <p>引数がBeansの場合は以下のように記述します。</p>
        <p>-  /*<span class="italic">引数名</span>.<span class="italic">プロパティ名</span>*/<span class="italic">リテラル</span></P>
        -->

        <p>引数名はDaoに設定したARGSアノテーションの値と揃える必要があります。(ただし引数が一つの場合は、その制約はありません。)</p>

<pre>
const getEmployee_ARGS = "empno";

public function List_getEmployee($empno);
</pre>

        <p>Daoに上記のメソッドを定義した場合、SQLファイル(EmploeeDao_List_getEmployee.sql)は次のようにバインド変数を使用することが可能です。
        自動的にList_getEmployeeメソッドの引数の値が設定されます。</p>

        <pre>SELECT * FROM emp WHERE empno = /*empno*/7788</pre>

        <!--
        <p>IN句にバインド変数を適用したい場合は以下のようにすることができます。</p>
        <p>-  IN /*<span class="italic">引数名</span>*/(...)</p>
        <pre>IN /*names*/('aaa', 'bbb')</pre>
        <p>引数はjava.util.Listや配列の引数となります。上記のIN句の場合は、以下のように引数を用意します。</p>
        <pre>String[] names = new String[]{"SCOTT", "SMITH", "JAMES"};</pre>
        <p>String配列namesが自動的にバインド変数の部分に置換されます。</p>
        -->

        <p>LIKEを使用する場合は、次のようにします。</p>
        <pre>ename LIKE /*ename*/'hoge'</pre>

        <!--
        <p>ワイルドカードを使いたい場合は、メソッドの引数の値に埋め込みます。
        「"COT"を含む」という条件を指定する場合は、以下のように引数の値にワイルドカードを埋め込みます。</p>
        <pre>employeeDao.findEmployees("%COT%");</pre>
        -->

        <h4>埋め込み変数コメント</h4>
        <p>Daoに定義したメソッドの引数の値をSQL文に文字列として直接埋め込む場合は、SQL文に埋め込み変数コメントを記述します。
        埋め込み変数コメントの右側のリテラルに引数の値が自動的に置換され実行されます。
        埋め込み変数コメントは、以下のように記述します。</p>
        <p>  -  /*<span class="italic">$引数名</span>*/<span class="italic">リテラル</span></p>

        <!--
        <p>引数がBeansの場合は以下のように記述します。</p>
        <p>-  /*<span class="italic">$引数名</span>.<span class="italic">プロパティ名</span>*/<span class="italic">リテラル</span></p>
        -->

        <h4>IFコメント</h4>
        <p>IFコメントでは、条件に応じて実行するSQL文を変えることが可能です。IFコメントは以下の形式で記述します。</p>

        <p> -  /*IF <span class="italic">条件</span>*/ .../*END*/</p>
        <p>サンプルは以下のとおりです。</p>

        <pre>/*IF hoge != null*/hoge = /*hoge*/'abc'/*END*/</pre>

        <p>IFコメントは、条件が真の場合、/*IF*/と/*END*/に囲まれた部分が評価されます。
        上記の場合、引数hogeがnull出ない場合にのみ、IFコメントで囲まれている部分(hoge = /*hoge*/'abc')が評価されます。
        <br />また偽の場合の処理としてELSEコメントというものが用意されています。
        条件が偽となった場合は、”ELSE”の後に記述した部分が評価されます。ELSEコメントは以下のように記述します。</p>

<pre>
/*IF hoge != null*/hoge = /*hoge*/'abc'
  -- ELSE hoge is null
/*END*/
</pre>

        <p>条件がfalseになると-- ELSEの後の部分(hoge is null)が評価されます。</p>

        <h4>BEGINコメント</h4>
        <p>BEGINコメントは、WHERE句内のすべてのELSEを含まないIFコメントがfalseになった場合に、
        WHERE句自体を出力したくない場合に使います。BEGINコメントはIFコメントと併せて使用します。<br />
        BEGINコメントは以下の形式で記述します。</p>
        <p>-   /*BEGIN*/<span class="italic">WHERE句</span>/*END*/</p>

        サンプルは以下の通りです。
<pre>
/*BEGIN*/WHERE
  /*IF job != null*/job = /*job*/'CLERK'/*END*/
  /*IF deptno != null*/AND deptno = /*deptno*/20/*END*/
/*END*/
</pre>

        <p>上記の場合、job,deptnoがnullの場合は、WHERE句は出力されません。
        job == null,deptno != nullの場合は、WHERE depno = ?、 job != null,deptno == nullの場合は、WHERE job = ?、
        job != null,deptno != nullの場合は、WHERE job = ? AND depno = ?のようになります。動的SQLも思いのままです。</p>

        <h3><a name="AutoUpdate">更新SQLの自動生成</a></h3>
        <p>更新SQL文を自動生成させるには、メソッド名を<a href="#DefMethod">命名規則</a>にあわせ、Beansを1つ引数に持つメソッドを定義するだけです。
        SQLファイルの作成は不要です。例としてInsertの場合、命名規則に合わせ、以下のように定義します。</p>

<pre>
public function insert(Department $department);
</pre>

        <h3><a name="AutoSelect">検索SQLの自動生成</a></h3>
        <p>メソッドのsignatueより、 S2Daoに自動的にSELECT文を生成させることもできます。ARGSアノテーションにカラム名を指定することで、
        引数の値によってWHERE句が変わるような動的なSQL文も自動生成できます。</p>
<pre>
SELECT * FROM emp
/*BEGIN*/WHERE
  /*IF job != null*/job = /*job*/'CLERK'/*END*/
  /*IF deptno != null*/AND deptno = /*deptno*/20/*END*/
/*END*/
</pre>
        <p>上記SQL文に相当するSQL文を自動生成するには以下のように定義します。上記SQLの/**/などについては、<a href="#SQLBind">SQLコメント</a>を参照してください。</p>
<pre>
const List_getEmployeeByJobDeptno_ARGS = "job, deptno";
const List_getEmployeeByJobDeptno($job, $deptno);
</pre>

<!--
        <p><a href="#N1Mapping">N:1でマッピング</a>されているカラムを指定する場合には、「カラム名_関連番号」で指定します。
        N:1でマッピングされているBeanは左外部結合を使って1つのSQL文で取得されます。左外部結合をサポートしていないRDBMSはSELECT文自動生成の対象外です。
        オラクルのように左外部結合が標準と異なる場合も、S2DaoがRDBMSがオラクルであると自動的に判断して適切なSQL文を組み立てます。</p>
        <p>引数にDTO（Data Transter Object）を指定することもできます。その場合、ARGSアノテーションを指定してはいけません。
        S2Daoは、引数が1つで、ARGSアノテーションが指定されていない場合、引数をDTOとみなし、DTOのプロパティを使って自動的にSQL文を組み立てます。
        プロパティ名とカラム名が異なる場合は、COLUMNアノテーションを使ってカラム名を指定します。N:1でマッピングされているカラムを指定する場合には、カラム名_関連番号で指定します。
        テーブルに存在しないプロパティ(カラム)は自動的に無視されます。プロパティの値によって、WHERE句が変わるような動的SQL文を自動生成します。<br />
        動的SQL文の自動生成とORDER BYではじまるQUERYアノテーションは併用することが出来ます。 </p>
<pre>
package examples.dao;

public class EmployeeSearchCondition {

    public static final String dname_COLUMN = "dname_0";
    private String job;
    private String dname;
    ...
}
</pre>
<pre>List getEmployeesBySearchCondition(EmployeeSearchCondition dto);</pre>
    <p>また同様の指定方法で引数にEntityを使用することも出来ます。DTOの詳しい使用方法は、<a href="#AutoSelectExample">自動で検索用SQL文を生成する場合のExample</a>を参照して下さい。</a>
-->

    <h3><a name="HowToRun">S2Daoの実行</a></h3>
    <p>Daoを実行する基本的な方法は以下のようになります。</p>
    <ol>
    <li>作成したdiconファイルのパスを引数にS2Containerを生成</li>
    <li>生成したS2ContainerからgetComponentを呼び出し、登録したDaoを取得する </li>
    <li>取得したDaoのメソッドを実行する</li>
    </ol>

    実行クラスサンプル
<pre>
&lt;?php
define("PATH", "examples/dao/EmployeeDao.dicon");
$container = S2ContainerFactory::create(PATH); /* 手順1 */
$dao = $container->getComponent("EmployeeDao"); /* 手順2 */
var_dump($dao->List_getAllEmployee(7788)); /* 手順3 */
?&gt;
</pre>

<!-- document end -->
<!-- don't edit start -->
</td>
<td width="14"><img height="14" width="14" src="images/spacer.gif" alt=""></td>
</tr><tr>
<td width="14"><img height="30" width="14" src="images/spacer.gif" alt=""></td>
<td width="766"><img height="30" width="592" src="images/spacer.gif" alt=""></td>
</tr><tr>
<td width="14"><img height="14" width="14" src="images/spacer.gif" alt=""></td>
<td width="766" class="copyright">&copy; Copyright The Seasar Foundation and the others 2004-2005, all rights reserved.</td>

</tr></table>
<td class="backright" align="left" valign="top">&nbsp;</td></tr><tr>
<td class="backunder" align="left"  valign="top" width="780" height="16">&nbsp;</td>
<td class="backcorner" align="left" valign="top" height="16">&nbsp;</td>
</tr></table></body>
<!-- don't edit end -->
</html>
